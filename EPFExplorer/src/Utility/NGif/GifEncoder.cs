using System;
using System.Drawing;
using System.IO;

#region .NET Disclaimer/Info
//===============================================================================
//
// gOODiDEA, uland.com
//===============================================================================
//
// $Header :		$  
// $Author :		$
// $Date   :		$
// $Revision:		$
// $History:		$  
//  
//===============================================================================
#endregion 

namespace NGif
{
	public class GifEncoder
	{
		protected int width;
		protected int height;
		protected Color transparent = Color.Empty; // transparent color if given
		protected int transIndex; // transparent index in color table
		protected int repeat = -1; // no repeat
		protected int delay = 0; // frame delay (hundredths)
		protected bool started = false; // ready to output frames
		protected Stream os; //output stream
		protected Image image; // current frame
		protected byte[] pixels; // BGR byte array from frame
		protected byte[] indexedPixels; // converted frame indexed to palette
		protected int colorDepth; // number of bit planes
		protected byte[] colorTab; // RGB palette
		protected bool[] usedEntry = new bool[256]; // active palette entries
		protected int palSize = 7; // color table size (bits-1)
		protected int dispose = -1; // disposal code (-1 = use default)
		protected bool closeStream = false; // close stream when finished
		protected bool firstFrame = true;
		protected bool sizeSet = false; // if false, get size from first frame
		protected int sample = 10; // default sample interval for quantizer

		public void SetDelay(int ms) 
		{
			delay = ( int ) Math.Round(ms / 10.0f);
		}
	
		/**
		 * Sets the GIF frame disposal code for the last added frame
		 * and any subsequent frames.  Default is 0 if no transparent
		 * color has been set, otherwise 2.
		 * @param code int disposal code.
		 */
		public void SetDispose(int code) 
		{
			if (code >= 0) 
			{
				dispose = code;
			}
		}
	
		/**
		 * Sets the number of times the set of GIF frames
		 * should be played.  Default is 1; 0 means play
		 * indefinitely.  Must be invoked before the first
		 * image is added.
		 *
		 * @param iter int number of iterations.
		 * @return
		 */
		public void SetRepeat(int iter) 
		{
			if (iter >= 0) 
			{
				repeat = iter;
			}
		}
	
		/**
		 * Sets the transparent color for the last added frame
		 * and any subsequent frames.
		 * Since all colors are subject to modification
		 * in the quantization process, the color in the final
		 * palette for each frame closest to the given color
		 * becomes the transparent color for that frame.
		 * May be set to null to indicate no transparent color.
		 *
		 * @param c Color to be treated as transparent on display.
		 */
		public void SetTransparent(Color c) 
		{
			transparent = c;
		}

		public GifEncoder()
		{
			Start();
		}

		public GifEncoder( Stream stream )
		{
			Start( stream );
		}

		private void Start()
		{
			Start( new MemoryStream() );
		}

		private void Start( Stream stream )
		{
			os = stream;
			WriteString( "GIF89a" );
		}


		public Stream Finish()
		{
			os.WriteByte( 0x3b ); // gif trailer
			os.Flush();
			return os;
		}

		public void AddFrame( Image image ) 
		{
			GetImagePixels();
			AnalyzePixels(); // build color table & map pixels
			if ( firstFrame ) 
			{
				WriteLSD(); // logical screen descriptior
				WritePalette(); // global color table
				if ( repeat >= 0 ) 
				{
					// use NS app extension to indicate reps
					WriteNetscapeExt();
				}
			}
			WriteGraphicCtrlExt(); // write graphic control extension
			WriteImageDesc(); // image descriptor
			if ( !firstFrame ) 
			{
				WritePalette(); // local color table
			}
			WritePixels(); // encode and write pixel data
		}

		protected void GetImagePixels() 
		{
			int w = image.Width;
			int h = image.Height;
			//		int type = image.GetType().;
			if ( ( w != width ) || ( h != height ) ) 
			{
				// create new image with right size/format
				Image temp =
					new Bitmap( width, height );
				Graphics g = Graphics.FromImage( temp );
				g.DrawImage( image, 0, 0 );
				image = temp;
				g.Dispose();
			}
			pixels = new Byte [ 3 * image.Width * image.Height ];
			int count = 0;
			Bitmap tempBitmap = new Bitmap( image );
			for (int th = 0; th < image.Height; th++)
			{
				for (int tw = 0; tw < image.Width; tw++)
				{
					Color color = tempBitmap.GetPixel(tw, th);
					pixels[count] = color.R;
					count++;
					pixels[count] = color.G;
					count++;
					pixels[count] = color.B;
					count++;
				}
			}
		}

		protected Byte[] GetImagePixels( Image image ) 
		{
			Byte [] pixels = new Byte [ 3 * image.Width * image.Height ];
			int count = 0;
			Bitmap tempBitmap = new Bitmap( image );
			for (int th = 0; th < image.Height; th++)
			{
				for (int tw = 0; tw < image.Width; tw++)
				{
					Color color = tempBitmap.GetPixel(tw, th);
					pixels[count] = color.R;
					count++;
					pixels[count] = color.G;
					count++;
					pixels[count] = color.B;
					count++;
				}
			}
			tempBitmap.Dispose();
			return pixels;
		}

		protected void AnalyzePixels() 
		{
			int len = pixels.Length;
			int nPix = len / 3;
			indexedPixels = new byte[nPix];
			NeuQuant nq = new NeuQuant(pixels, len, sample);
			// initialize quantizer
			colorTab = nq.Process(); // create reduced palette
			int k = 0;
			for (int i = 0; i < nPix; i++) 
			{
				int index =
					nq.Map(pixels[k++] & 0xff,
					pixels[k++] & 0xff,
					pixels[k++] & 0xff);
				usedEntry[index] = true;
				indexedPixels[i] = (byte) index;
			}
			pixels = null;
			colorDepth = 8;
			palSize = 7;
			// get closest match to transparent color if specified
			if (transparent != Color.Empty ) 
			{
				transIndex = FindClosest(transparent);
			}
		}
	
		protected int FindClosest( Color color ) 
		{
			if (colorTab == null) return -1;
			int r = color.R;
			int g = color.G;
			int b = color.B;
			int minpos = 0;
			int dmin = 256 * 256 * 256;
			int len = colorTab.Length;
			for (int i = 0; i < len;) 
			{
				int dr = r - (colorTab[i++] & 0xff);
				int dg = g - (colorTab[i++] & 0xff);
				int db = b - (colorTab[i] & 0xff);
				int d = dr * dr + dg * dg + db * db;
				int index = i / 3;
				if (usedEntry[index] && (d < dmin)) 
				{
					dmin = d;
					minpos = index;
				}
				i++;
			}
			return minpos;
		}

		/**
		 * Writes Logical Screen Descriptor
		 */
		protected void WriteLSD()  
		{
			// logical screen size
			WriteShort(width);
			WriteShort(height);
			// packed fields
			os.WriteByte( Convert.ToByte (0x80 | // 1   : global color table flag = 1 (gct used)
				0x70 | // 2-4 : color resolution = 7
				0x00 | // 5   : gct sort flag = 0
				palSize) ); // 6-8 : gct size

			os.WriteByte(0); // background color index
			os.WriteByte(0); // pixel aspect ratio - assume 1:1
		}

		/**
		 * Writes color table
		 */
		protected void WritePalette()
		{
			os.Write( colorTab, 0, colorTab.Length );
			int n = ( 3 * 256 ) - colorTab.Length;
			for ( int i = 0; i < n; i++ ) 
			{
				os.WriteByte( 0 );
			}
		}

		/**
		 * Writes Netscape application extension to define
		 * repeat count.
		 */
		protected void WriteNetscapeExt()
		{
			os.WriteByte(0x21); // extension introducer
			os.WriteByte(0xff); // app extension label
			os.WriteByte(11); // block size
			WriteString("NETSCAPE" + "2.0"); // app id + auth code
			os.WriteByte(3); // sub-block size
			os.WriteByte(1); // loop sub-block id
			WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)
			os.WriteByte(0); // block terminator
		}

		protected void WriteGraphicCtrlExt() 
		{
			os.WriteByte(0x21); // extension introducer
			os.WriteByte(0xf9); // GCE label
			os.WriteByte(4); // data block size
			int transp, disp;
			if (transparent == Color.Empty ) 
			{
				transp = 0;
				disp = 0; // dispose = no action
			} 
			else 
			{
				transp = 1;
				disp = 2; // force clear if using transparent color
			}
			if (dispose >= 0) 
			{
				disp = dispose & 7; // user override
			}
			disp <<= 2;

			// packed fields
			os.WriteByte( Convert.ToByte( 0 | // 1:3 reserved
				disp | // 4:6 disposal
				0 | // 7   user input - 0 = none
				transp )); // 8   transparency flag

			WriteShort(delay); // delay x 1/100 sec
			os.WriteByte( Convert.ToByte( transIndex)); // transparent color index
			os.WriteByte(0); // block terminator
		}
	
		/**
		 * Writes Image Descriptor
		 */
		protected void WriteImageDesc()
		{
			os.WriteByte(0x2c); // image separator
			WriteShort(0); // image position x,y = 0,0
			WriteShort(0);
			WriteShort(width); // image size
			WriteShort(height);
			// packed fields
			if (firstFrame) 
			{
				// no LCT  - GCT is used for first (or only) frame
				os.WriteByte(0);
			} 
			else 
			{
				// specify normal LCT
				os.WriteByte( Convert.ToByte( 0x80 | // 1 local color table  1=yes
					0 | // 2 interlace - 0=no
					0 | // 3 sorted - 0=no
					0 | // 4-5 reserved
					palSize ) ); // 6-8 size of color table
			}
		}

		protected void WritePixels()
		{
			LZWEncoder encoder =
				new LZWEncoder( width, height, indexedPixels, colorDepth );
			encoder.Encode( os );
		}
	
		protected void WriteShort(int value)
		{
			os.WriteByte( Convert.ToByte( value & 0xff));
			os.WriteByte( Convert.ToByte( (value >> 8) & 0xff ));
		}
	
		protected void WriteString( string text )
		{
			char[] chars = text.ToCharArray();
			for (int i = 0; i < chars.Length; i++) 
			{
				os.WriteByte( ( byte ) chars[i] );
			}
		}
	}

}